// lib/functions.ts
import { createHmac, randomBytes } from "node:crypto";

// lib/constants/allowed-hash-algorithms.ts
var allowedHashAlgorithms = ["sha256", "sha512"];
var allowed_hash_algorithms_default = allowedHashAlgorithms;

// lib/utils/is-allowed-value.util.ts
var isAllowedValue = (value, allowedValues) => {
  if (typeof value !== "string") {
    return false;
  }
  return allowedValues.includes(value);
};
var is_allowed_value_util_default = isAllowedValue;

// lib/constants/allowed-hash-digests.ts
var allowedHashDigests = [
  "base64",
  "base64url",
  "hex",
  "binary"
];
var allowed_hash_digests_default = allowedHashDigests;

// lib/default-password.config.ts
var defaultPasswordConfiguration = {
  hashAlgorithm: "sha512",
  hashDigest: "hex",
  inSeparator: "."
};
var default_password_config_default = defaultPasswordConfiguration;

// lib/adapter/safe-password-configuration.adapter.ts
var safePasswordConfigurationAdapter = (configuration) => {
  if (!configuration) {
    console.log("[PasswordBuilder]: No configuration provided. Default configuration will be used." /* NoConfigurationProvided */);
    return default_password_config_default;
  }
  const configurationIsArray = Array.isArray(configuration);
  if (typeof configuration !== "object" && typeof configuration !== "undefined" || configurationIsArray) {
    throw new Error("[PasswordBuilder]: The configuration must be an valid configuration object or undefined." /* ConfigurationMustBeAnObjectOrUndefined */);
  }
  if (typeof configuration.hashAlgorithm !== "string" || typeof configuration.hashDigest !== "string") {
    throw new Error("[PasswordBuilder]: hashAlgorithm and hashDigest must be strings." /* HashAlgorithmAndHashDigestMustBeStrings */);
  }
  const hashAlgorithmIsValid = is_allowed_value_util_default(
    configuration.hashAlgorithm,
    allowed_hash_algorithms_default
  );
  const hashDigestIsValid = is_allowed_value_util_default(
    configuration.hashDigest,
    allowed_hash_digests_default
  );
  const inSeparatorValue = configuration.inSeparator && typeof configuration.inSeparator === "string" ? configuration.inSeparator : default_password_config_default.inSeparator;
  if (!hashAlgorithmIsValid || !hashDigestIsValid) {
    console.warn(
      "[PasswordBuilder]: One or more of the provided hash configuration values seem to be invalid. Default values will be used." /* OneOrMoreOfTheProvidedHashConfigurationValuesSeemToBeInvalid */
    );
  }
  return {
    hashAlgorithm: hashAlgorithmIsValid ? configuration.hashAlgorithm : default_password_config_default.hashAlgorithm,
    hashDigest: hashDigestIsValid ? configuration.hashDigest : default_password_config_default.hashDigest,
    inSeparator: inSeparatorValue
  };
};
var safe_password_configuration_adapter_default = safePasswordConfigurationAdapter;

// lib/functions.ts
var DEFAULT_SALT_ROUNDS = 11;
function hasher(password, salt, configuration) {
  const hash2 = createHmac(configuration.hashAlgorithm, salt);
  hash2.update(password);
  const value = hash2.digest(configuration.hashDigest);
  return `${salt}${configuration.inSeparator}${value}`;
}
function hash(password, salt, configuration) {
  if (password == null || salt == null) {
    throw new Error("Must Provide Password and salt values");
  }
  if (typeof password !== "string" || typeof salt !== "string") {
    throw new Error(
      "password must be a string and salt must either be a salt string or a number of rounds"
    );
  }
  const safeConfiguration = safe_password_configuration_adapter_default(configuration);
  return hasher(password, salt, safeConfiguration);
}
function generateSalt(rounds = DEFAULT_SALT_ROUNDS) {
  if (typeof rounds !== "number") {
    throw new Error("rounds param must be a number");
  }
  if (rounds < 0) {
    throw new Error("rounds param must be greater than 0");
  }
  if (rounds > 13) {
    console.warn(
      "[PasswordBuilder]: Consider setting rounds param to 13 or lower for production, as this may cause high CPU usage."
    );
  }
  const salt = randomBytes(Math.ceil(rounds / 2)).toString("hex");
  return salt.slice(0, rounds);
}
function verify(password, hashedPassword, configuration) {
  if (hashedPassword == null) {
    throw new Error("Must Provide hashedPassword");
  }
  const safeConfiguration = safe_password_configuration_adapter_default(configuration);
  const subPass = hashedPassword.split(safeConfiguration.inSeparator);
  const passwordHashConfiguration = {
    salt: subPass[0],
    hashedPassword: subPass[1]
  };
  if (typeof password !== "string" || typeof passwordHashConfiguration !== "object") {
    throw new Error(
      "password must be a String and hash must be an Object of { salt, hashedPassword }"
    );
  }
  const hash2 = hasher(
    password,
    passwordHashConfiguration.salt,
    safeConfiguration
  );
  if (password == null || hash2 == null) {
    throw new Error("password and hash is required to compare");
  }
  if (hash2 === hashedPassword && password.length > 0 && hash2.length > 0) {
    return true;
  }
  return false;
}
export {
  generateSalt,
  hash,
  verify
};
